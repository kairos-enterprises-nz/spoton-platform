"""
Application layer models - to be configured later

Raw data import is handled by Airflow DAGs → TimescaleDB (direct SQL)
Application logic models will be configured later for business features.
"""

# Application layer models will be configured later
# Raw data import is handled by Airflow DAGs → TimescaleDB directly

import uuid
from django.db import models
from core.models import TenantAwareUUIDModel


class SwitchStatus(models.TextChoices):
    INITIATED = 'INITIATED', 'Initiated'
    NT_SENT = 'NT_SENT', 'NT Sent'
    AN_RECEIVED = 'AN_RECEIVED', 'AN Received'
    CS_AWAITED = 'CS_AWAITED', 'CS Awaited'
    COMPLETED = 'COMPLETED', 'Completed'
    RR_SENT = 'RR_SENT', 'RR Sent'
    RR_RECEIVED = 'RR_RECEIVED', 'RR Received'
    READING_CORRECTED = 'READING_CORRECTED', 'Reading Corrected'
    WITHDRAWAL_SENT = 'WITHDRAWAL_SENT', 'Withdrawal Sent'
    WITHDRAWAL_RECEIVED = 'WITHDRAWAL_RECEIVED', 'Withdrawal Received'
    WITHDRAWN = 'WITHDRAWN', 'Withdrawn'
    FAILED = 'FAILED', 'Failed'


class SwitchRequest(TenantAwareUUIDModel):
    """
    Switch request for white-label brand customers.
    All switches are under the same market participant (SpotOn) but isolated by tenant/brand.
    """
    contract = models.OneToOneField(
        'contracts.ElectricityContract', 
        on_delete=models.CASCADE, 
        related_name='switch_request'
    )
    
    # For white-labeling, gaining_trader is typically the same (SpotOn)
    # but we track the tenant brand for customer isolation
    gaining_trader_code = models.CharField(
        max_length=20, 
        default='SPON',
        help_text="Market participant code (typically SPON for SpotOn)"
    )
    losing_trader_code = models.CharField(
        max_length=20,
        default='UNKNOWN',
        help_text="Previous retailer's market participant code"
    )
    
    status = models.CharField(
        max_length=30, 
        choices=SwitchStatus.choices, 
        default=SwitchStatus.INITIATED, 
        db_index=True
    )
    
    nt_sent_at = models.DateTimeField(
        null=True, 
        blank=True, 
        help_text="Timestamp of successful NT file upload."
    )
    actual_transfer_date = models.DateField(null=True, blank=True)
    
    override_active = models.BooleanField(
        default=False, 
        help_text="If True, all automated DAGs will skip execution for this request."
    )
    override_reason = models.TextField(
        blank=True, 
        null=True, 
        help_text="Mandatory reason if an override is active."
    )
    error_message = models.TextField(blank=True, null=True)

    class Meta:
        db_table = 'energy_switchrequest'
        indexes = [
            models.Index(fields=['tenant', 'status']),
            models.Index(fields=['gaining_trader_code', 'losing_trader_code']),
            models.Index(fields=['actual_transfer_date']),
        ]

    def __str__(self):
        return f"Switch for {self.contract.icp_code} - {self.status} (Brand: {self.tenant.name})"
    
    def _validate_tenant_consistency(self):
        """Validate tenant consistency with contract"""
        super()._validate_tenant_consistency()
        
        if self.contract and self.contract.tenant != self.tenant:
            from django.core.exceptions import ValidationError
            raise ValidationError("Switch request and contract must belong to the same tenant/brand")


class RegistryMessage(TenantAwareUUIDModel):
    """
    Registry messages for switch requests.
    Isolated by tenant/brand for white-label operations.
    """
    switch_request = models.ForeignKey(
        'SwitchRequest', 
        on_delete=models.CASCADE, 
        related_name='messages'
    )
    message_type = models.CharField(
        max_length=10, 
        db_index=True, 
        help_text="e.g., 'RS-010', 'RS-020'"
    )
    direction = models.CharField(
        max_length=10, 
        choices=[('INBOUND', 'INBOUND'), ('OUTBOUND', 'OUTBOUND')]
    )
    payload = models.JSONField(help_text="The parsed content of the file.")
    sftp_filename = models.CharField(
        max_length=255, 
        help_text="The original filename on the SFTP server."
    )
    is_manual_override = models.BooleanField(
        default=False, 
        help_text="True if this message was generated by a user action."
    )
    timestamp = models.DateTimeField(auto_now_add=True, db_index=True)

    class Meta:
        db_table = 'energy_registrymessage'
        indexes = [
            models.Index(fields=['tenant', 'message_type', 'direction']),
            models.Index(fields=['switch_request', 'timestamp']),
            models.Index(fields=['sftp_filename']),
        ]

    def __str__(self):
        return f"{self.direction} message {self.message_type} for {self.switch_request.id} (Brand: {self.tenant.name})"
    
    def _validate_tenant_consistency(self):
        """Validate tenant consistency with switch request"""
        super()._validate_tenant_consistency()
        
        if self.switch_request and self.switch_request.tenant != self.tenant:
            from django.core.exceptions import ValidationError
            raise ValidationError("Registry message and switch request must belong to the same tenant/brand")
